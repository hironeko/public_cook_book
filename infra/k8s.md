## k8s の学習メモ

- 書籍：15step で習得 Docker から入る Kubernetes

### 第 1 章 2

- コンテナの理解が前提

##### Docker を利用する価値

- 基盤利用の効率を高める

  - 小型軽量のコンテナを物理サーバーや仮想サーバーの上で混在動作できる
  - CPU やメモリの使用率を高め、ハードウェアを高効率で利用

- 迅速な利用開始

  - 仮想サーバーや物理サーバーよりも、コンテナの起動時間は短い
  - OS、アプリケーション、ミドルウェアなど様々なイメージをレジストリから入手可能
  - ネットワーク、ボリュームをソフトウェア定義のオブジェクトとして作成できる

- 不変の実行基盤
  - アプリケーションなどの実行に必要なソフトウェアを含むコンテナを作成
  - コンテナの組み合わせでシステムを構成することでサーバー基盤から分離
  - アプリケーションの開発環境から本番環境への移行に変更不要

##### 仮想サーバーとコンテナの違い

- 仮想サーバー

  - 共有ハードウェアが必要
  - そのハードウェア上であたかも 1 台の専用サーバーであるかのように利用できる

- コンテナ
  - Linux のプロセスの 1 つが専用サーバーで動作しているような、分離された状態を作り出す
  - コンテナ実行環境には、Linux のカーネル環境が利用できるようにするために、必ず仮想サーバーが必要となる
  - ハイパーバイザーの上で LinuxKit が動き、その上でコンテナのランタイム containerd が動作するようになっている
  -  ハイパーバイザー上の仮想サーバーでも利用でき、また、仮想サーバーの構築は自動化しやすことから、省力化と迅速性を優先して、パブリッククラウドの仮想サーバーや、オンプレの OpenStack の仮想サーバー上でも多く利用されている

##### Docker のアーキテクチャ

- Docker の実行順番

1. docker コマンドを実行 → docker コマンドは、Dockerfile を読み取る
2. Docker デーモンへ要求が飛び、コンテナホストにイメージが存在しなければレジストリから取得を行う(Docker Hub)
3. コンテナホスト側へイメージがローカルのリポジトリに保存される
4. イメージはコンテナへ変換されインスタンス化され、IP アドレスが割り当てられる 1 つのサーバーのように動作する

   > 補足：docker コマンドにオプションを加えることで同じイメージから作られたコンテナでも、異なるサービスを提供することが可能。よってコンテナの再利用生を飛躍的に高めることができる

   > またコンテナを停止したあとに再起動行うと停止前の IP アドレスを保持しないためその時点で割り当てが可能な IP アドレスが割り当てられるため IP アドレスが変わる

- 基本的な Docker の構成要素(P738 参照)
  - Docker デーモン
    - docker コマンドの要求を受け取り、イメージ、コンテナ、ボリューム、ネットわーといった Docker オブジェクトを管理する。ネットワークを超えてのリクエストを受け取ることも可能
  - Docker クライアント
    - Docker デーモンへ要求を送る docker コマンド
    - 例：docker build → ベースのイメージから、機能を加えた新イメージを作る
  - イメージ
    - 読み取り専用のコンテナテンプレートです
  - Docker レジストリ
  - コンテナのイメージを保管する。default では、Docker Hub になっている
  - レジストリは、リポジトリを複数保管するサービス
  - リポジトリは、イメージに対してタグを付加して、識別するように保管するもの

##### レジストリと Kubernetes の関係

- Kubernetes 上でコンテナを実行する時もレジストリの中のリポジトリからコンテナイメージをダウンロードし、インスタンスかして実行する

  > P840 の図 7 参照

- Kubernetes 上でコンテナが動作するまでの流れ

1. docker build でイメージをビルド
2. docker push でイメージをレジストリに登録する
3. kubectl コマンドで マニュフェストからオブジェクトの生成を要求
4. マニュフェストに記述されたリポジトリからコンテナを pull (ダウンロード)
5. コンテナをポッド上で起動する

##### Docker と Kubernetes の連携

- Kubernetes は、Docker をコンテナのランタイム環境として利用してきた(すなわち実行環境のこと)

> containerd プロセスは、コンテナホスト上で、イメージを転送、保管、実行、ボリュームやネットワーク接続などのコンテナの完全なライフサイクルを管理できる

> kubelet と連携できるようになった

> > Docker のアーキテクチャ簡易まとめ：Docker デーモンがサーバーであり docker コマンドがクライアントである。

### 第 1 章 3

##### Kubernetes の基本

- アーキテクチャ 参照：P1072

  - マスターとノードと呼ばれるサーバーから構成される
  - kubectl → kube-apiserver へ要求をおくる
    - マスターサーバー
      - kube-apiserver, kube-scheduler, kube-controller, etcd
    - ノード → サーバーの役割を表す名前
      - kube-proxy, kubelet
      - Pod
        - container

- 構成要素概要
  - kubectl
    - K8s クラスタを操作するためのコマンド
  - kube-apiserver
    - API サーバーは kubectl などの API クライアントからの REST リクエストを検証して API オブジェクトを構成、または、状態を報告する
  - kube-scheduler
    - ワークロード専用のスケジュール機能である
  - kube-controller-manager
    - 制御ループを使ってシステム状態を調整する。モニタリングした現在状態から希望状態への遷移を実行する
  - cloud-controller-manager
    - API を通じてクラウドサービスと連携するコントローラであり、クラウド各社によって実装される
  - etcd
    - K8s クラスタのすべての管理データは etcd で保存される。
  - kubelet
    - 各ノードで動作する。
    - ボッッドとコンテナの実行
    - ポッドとノードの状態を API サーバーへ報告する
    - コンテナを検査するブローブを実行
    - 内臓する cAdvisor がメトリックスを集約して公開する
  - kube-proxy
    - 各ノードで動作し、高可用性かつ低オーバーヘッドのロードバランシングを提供
    - サービスとポッドの変更を API サーバーで監視し、構成を最新状態に保ち、ポッド間とノード間の通信を確実にする
    - サービスの生成時に ClusterIP へのパケットをトラップして、対応するポッドへリダイレクトするように、iptables のルールを操作する
    - サービス名と ClusterIP をアドオンの DNS へ登録する
  - coredns
    - ポッドがサービス名から IP アドレスを得るために利用されている
  - kube-flannel
    - すべてのノードで実行され、複数のノードの間で IPv4 ネットワークを提供する。これによりコンテナ(ノード)は K8s 内部の IP アドレスでノードを超えて、疎通できるようになる
    - ネットワークポリシーを必要とする場合には、calico を使用しなければならない
  - calico-kube-controllers
    - calico のためのコントローラ。データストアとしての etcd を利用するために使われる
  - calico-node
    - 全てのノードで実行され、ノード間のコンテナ(ポッド)の疎通、アクセスコントロール、ルーティングを提供
  - kubernetes-dashboard
    - WebUI
  - metrics-server
    - heapster に代わり API の aggregation layer を通じて、K8s クラスタ全体のメトリクスを収集する

#### Kubernetes の階層構造

参照：P1103

> Kubernetes の「スケジュール」とは、ポッドの実行をノードへ割り当てることを意味する

- マスターは、各ノードの CPU とメモリの予約料、及実際の使用量を監視しています。

##### Kubernetes API とは？

- Kubernetes の操作は、すべて API を通じて行います。

  - kubectl コマンドは、「マスター」ノード上の kube-apiserver に対して目標自体の宣言書＝マニュフェストを送信し、オブジェクトの作成・変更・削除と状態の取得を行う。
  - Go や Python といった言語から Kubernetes を操作することで自動化も可能

- オブジェクトとは？

  - K8s クラスタ内部のエンティティ(実体)である
  - ポッド、コントローラ、サービスなどのインスタンスを指す

- ワークロード

  - オブジェクトのカテゴリを表す
  - ただしアプリケーションなどのプログラミの実行負荷を意味する場合もある

- コンテナ

  - 必ずポッド内で実行する
  - 軌道に設定できる項目がある

- ポッド

  - コンテナを実行するためのオブジェクトで、複数のコンテナを内包している

- コントローラ

  - ポッドの実行を制御するオブジェクト

- コンフィグレーション

  - コンテナ内のアプリケーションの設定やパスワードなどの情報は、デプロイされた「名前空間」から取得することが推奨されている。
  - 設定を保存する：ConfigMap(コンフィグマップ)
  - 秘匿情報を保存する：Secret(シークレット)
  - 名前空間下に保存された情報は、コンテナ内のファイルや環境変数として、アプリケーションのコードから参照できるようになる

- サービス

  - ポッドとサービス名を具体的に紐づける役割を負います
  - かなり重要なオブジェクトのため別途詳細がある

- ストレージ
  - ポッドもコンテナも実行時の一時的な存在であるため、データをコンテナ上のファイルシステムに保存することができない
  - そのため永続ボリュームにデータを保存しなければならない。ただし複数のノード上からアクセスできる永続ボリュームの実体は、Kubernetes の範囲に含まれないため、外部ストレージシステムに依存することになる
  - そのため AWS や GCP などのそれぞれ異なるストレージサービスやプロトコル、API を利用しないといけない
    - ストレージシステムの違いを隠蔽してコンテナの共通した API によって「永続ボリューム」をアクセスできるようにしています。

### ポッドの基本

- Kubernetes におけるコンテナの最小実行単位であり、1 つまたは、複数のコンテナを含んだ 1 つのグループです。内包するすべてのコンテナは、同じノード上で動作する

- ポッドの特徴

  - ポッド内部のコンテナは、ポッドの IP アドレスとポート番号を共有し、ポッドを外部に向けてポートを開くことができる
  - ポッド内部のコンテナ同志は、localhost の IP アドレスとポート番号で互いに通信できる
  - ポッド内部のコンテナの間で System V のプロセス間通信及 POSIX 共有メモリを使用して互いに通信できる
  - ポッド内部のコンテナは、ポッドのボリュームをコンテナからクロスマウントして、ポッド内でファイルシステムを共有できる
  - ポッドは一時的な存在でしかないため IP アドレスは、起動毎に変化する。ポッドの再起動は、初期状態に戻る

- ポッドの特徴まとめ
  - ポッドは、IP アドレスを持ち、複数のコンテナを内包し、1 つの仮想サーバーのように動作するが従来のサーバーのように大切にシステム管理するものでなく、使い捨ての一時的な存在として運用するように設計されている
  - 単体でも起動し利用できるが「サービス」「コントローラ」「永続ボリューム」「コンフィグマップ」「シークレット」などのオブジェクトと組み合わせて使用することで進化を発揮する

##### 最も多い Kubernetes のトラブルシューティングの中で最も多いのは、起動失敗の原因調査

参照：P1224 表 4

- ContainerCreating

  - イメージをダウンロード中、またはコンテナ起動進行中を表す。
  - ConfigMap や Secret をマウントできず、コンテナ生成が保留された時もこの値が表示される

- CrashLoopBackOff

  - ボッド内のコンテナが終了し、次の起動まで待機状態になる。
  - コンテナ内のプロセスを見直す必要がある

- Pending

  - ポッド生成の要求を受け取るが、1 つ以上のコンテナが作成されていない状態
  - リソース不足、ポリシー制約によってスケジュールできていないケースがあるため見直す

- Running

  - ノードに対応づけられ、少なくとも 1 つのコンテナが実行中、開始中、または再起動中である

- Terminating

  - コンテナへの終了要求シグナルが送られ、コンテナが終了するまで待機中
  - 猶予時間をすぎ、コンテナが終了できていない場合、強制終了する

- Succeeded
  - 正常

* Completed

  - ポッド内のコンテナが正常終了し存在している。削除されるまで存在し続ける。ポッド名を指定することでログやステータスを取得できる
  - ポッド内に複数のコンテナがある場合、第 1 コンテナが正常終了するとポッドは、正常終了として扱われる

* Error

  - コンテナが異常終了した。
  - Completed の対義

* Failed

  - ポッドないの少なくとも 1 つのコンテナが異常終了した

* Unknown
  - 何らかの理由により、ポッドの状態を取得できない状態
  - また、ノード障害、マスターからノードの状態を取得できなくなったときにもこの表示になる

##### ポッドの終了処理

- 基本的には、Kubernetes は、アプリケーションのコードが終了要求シグナルを受け取ったら、猶予時間内に終了処理を完了して、正常終了するように要求してます

-

##### クラスタネットワーク

- K8s クラスタの内部ネットワークであり、ポッドの IP アドレスとポッドのクラスタの代表 IP アドレスは、このネットワーク上における IP アドレスになる。異なるノードに配置されたポッド間でも疎通できるようにします

##### サービスの基本

参照:P1262/図 3

- クライアントは、「サービス」がもつ代表 IP アドレスを利用してアクセスしなければならない

- サービスはロードバランサーの役割を持ち、ポッドを代表する IP アドレスを書くとしてクライアントのリクエストをうける
